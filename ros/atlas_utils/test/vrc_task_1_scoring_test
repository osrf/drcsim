#!/usr/bin/env python

from __future__ import print_function
import unittest
import rostest
import sys
import time
import rospy
import shutil
import os
import tempfile
import subprocess
from geometry_msgs.msg import Pose

LOGDIR = '/tmp/vrc_task_1'

class Tester(unittest.TestCase):

    def _grep(self, fname, string):
        fullpath = os.path.join(LOGDIR, fname)
        for line in open(fullpath, 'r'):
            if string in line:
                return True
        return False

    def _get_atlas_pose(self, fname):
        # Check the current robot pose, from the incomplete gazebo log
        # file. Not sure how robust this is.
        fullpath = os.path.join(LOGDIR, fname)
        while not os.path.exists(fullpath):
            print('Waiting for %s to exist'%(fullpath))
            time.sleep(0.5)
        tmp = tempfile.NamedTemporaryFile(delete=False)
        tmp.close()
        shutil.copyfile(fullpath, tmp.name)
        # Terminate our copy of the log file
        with open(tmp.name, 'a') as f:
            f.write('</gazebo_log>\n')
        # Use gzlog to extract the pose
        cmd = ['gzlog', 'echo', tmp.name, '-r', '--filter', 'atlas.pose']
        po = subprocess.Popen(cmd, stdout=subprocess.PIPE, 
                              stderr=subprocess.PIPE)
        out,err = po.communicate()
        # Take the last non-empty line
        pose = []
        for l in reversed(out.split('\n')):
            if len(l) > 0 and l[0] != ' ':
                pose = l.split()
                break
        print('pose:%s'%(pose))
        self.assertTrue(len(pose) == 6)
        for i in range(len(pose)):
            pose[i] = float(pose[i])
        print("tmplog: %s"%(tmp.name))
        #os.remove(tmp.name)
        return pose

    def test_scoring(self):
        pose_pub = rospy.Publisher('atlas/set_pose', Pose)
        enter_car_pub = rospy.Publisher('drc_world/robot_enter_car', Pose)
        # Wait for subscribers to hook up
        time.sleep(3.0)

        # Teleport through first gate
        self.assertFalse(self._grep('score.log', 
          'Successfully passed through gate 0'))
        after_gate_0_pose = Pose()
        after_gate_0_pose.position.x = -9.75
        after_gate_0_pose.position.y = -4.11
        after_gate_0_pose.position.z = 0.91
        pose_pub.publish(after_gate_0_pose)
        time.sleep(5.0)
        self.assertTrue(self._grep('score.log', 
          'Successfully passed through gate 0'))
        # Also check the pose from the in-progress gazebo state.log
        atlas_pose = self._get_atlas_pose('state.log')
        self.assertAlmostEqual(atlas_pose[0], after_gate_0_pose.position.x, 1)
        self.assertAlmostEqual(atlas_pose[1], after_gate_0_pose.position.y, 1)
        #self.assertAlmostEqual(atlas_pose[2], after_gate_0_pose.position.z, 1)

        # Jump in the car
        self.assertFalse(self._grep('score.log', 
          'Successfully moved Atlas into vehicle'))
        in_car_pose = Pose()
        enter_car_pub.publish(in_car_pose)
        time.sleep(3.0)
        self.assertTrue(self._grep('score.log', 
          'Successfully moved Atlas into vehicle'))

if __name__ == '__main__':
    # Remove the old log files; here I'm counting on coming up first, before
    # Gazebo tries to write to the logs.
    if os.path.exists(LOGDIR):
        shutil.rmtree(LOGDIR)

    rospy.init_node('vrc_task_1_scoring_test', anonymous=True)

    # Wait until /clock is being published; this can take an unpredictable
    # amount of time when we're downloading models.
    while rospy.Time.now().to_sec() == 0.0:
        print('Waiting for Gazebo to start...')
        time.sleep(1.0)
    # Take an extra nap, to allow plugins to be loaded
    time.sleep(5.0)
    print('OK, starting test.')

    rostest.run('atlas_utils', 'vrc_task_1_scoring_test', Tester, sys.argv)

